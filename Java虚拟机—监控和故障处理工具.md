# 虚拟机性能监控与故障处理工具

JDK监控和故障处理工具

| 名称     | 主要作用                                                                     |
| ------ | ------------------------------------------------------------------------ |
| jps    | JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程                          |
| jstat  | JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据                    |
| jinfo  | Configuration info for Java，显示虚拟机配置信息                                    |
| jmap   | Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）                            |
| jhat   | JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP／HTML服务器，让用户可以在浏览器上查看分析结果 |
| jstack | Stack Trace for Java，显示虚拟机的线程快照                                         |


## jstack：Java堆栈跟踪工具

jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致长时间等待等都是导致线程长时间停顿的常见原因。


新生代和永久代

## VisualVM：多合一故障处理工具

VisualVM在JDK1.6 update 7中才首次出现，但并不意味着它只能监控运行于JDK 1.6上的程序，它具备很强的向下兼容能力，甚至能向下兼容至近10年前发布的JDK 1.4.2平台，这对无数已经处于实施、维护的项目很有意义。当然，并非所有功能都能完美地向下兼容。


**过大的堆内存进行回收时带来的长时间的停顿**。

对于用户交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用，譬如十几个小时乃至一天才出现一次Full GC，这样可以通过在深夜执行定时任务的方式触发Full GC甚至自动重启应用服务器保持内存可用空间在一个稳定的水平。

控制Full GC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。


JBossCache

进程内存是有限制的

堆外内存溢出

Direct Memory却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。否则它只能一直等到抛出内存溢出异常时


虚拟机进程自动关闭

Minor GC  
Major GC