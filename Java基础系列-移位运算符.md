---
title: Java移位运算符
date: 2017-02-06 10:09:50
tags: Java
---

Java移位运算符详解

<!-- more -->

# Java移位运算符：<<(左移)、>>(带符号右移)和>>>(无符号右移)
# 1、 左移运算符

　　左移运算符 << 使指定值的所有位都左移规定的次数。

　　1）它的通用格式如下所示：

　　value << num

　　num 指定要移位值value 移动的位数。

　　左移的规则只记住一点：丢弃最高位，0补最低位

　　如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动33位，实际上只移动了332=1位。

　　2）运算规则

　　按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。

　　当左移的运算数是int 类型时，每移动1位它的第31位就要被移出并且丢弃；

　　当左移的运算数是long 类型时，每移动1位它的第63位就要被移出并且丢弃。

　　当左移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。

　　3）数学意义

　　在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方

　　4）计算过程：

　　例如：3 <<2(3为int型)

　　1）把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011，

　　2）把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位，

　　3）在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100，

　　转换为十进制是12。

　　移动的位数超过了该类型的最大位数，

　　如果移进高阶位（31或63位），那么该值将变为负值。下面的程序说明了这一点：

　　Java代码

　　// Left shifting as a quick way to multiply by 2.

　　public class MultByTwo {

　　public static void main(String args[]) {

　　int i;

　　int num = 0xFFFFFFE;

　　for(i=0; i<4; i++) {

　　num = num << 1;

　　System.out.println(num);

　　}

　　}

　　}

　　该程序的输出如下所示：

　　536870908

　　1073741816

　　2147483632

　　-32

　　注：n位二进制，最高位为符号位，因此表示的数值范围-2^(n-1) ——2^(n-1) -1,所以模为2^(n-1)。

　　2、 右移运算符

　　右移运算符<<使指定值的所有位都右移规定的次数。

　　1）它的通用格式如下所示：

　　value >> num

　　num 指定要移位值value 移动的位数。

　　右移的规则只记住一点：符号位不变，左边补上符号位

　　2）运算规则：

　　按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1

　　当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。

　　例如，如果要移走的值为负数，每一次右移都在左边补1，如果要移走的值为正数，每一次右移都在左边补0，这叫做符号位扩展（保留符号位）（sign extension ），在进行右移

　　操作时用来保持负数的符号。

　　3）数学意义

　　右移一位相当于除2，右移n位相当于除以2的n次方。

　　4）计算过程

　　11 >>2(11为int型)

　　1)11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011

　　2)把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。

　　3)最终结果是0000 0000 0000 0000 0000 0000 0000 0010。

　　转换为十进制是2。

　　35 >> 2(35为int型)

　　35转换为二进制：0000 0000 0000 0000 0000 0000 0010 0011

　　把低位的最后两个数字移出：0000 0000 0000 0000 0000 0000 0000 1000

　　转换为十进制： 8

　　5）在右移时不保留符号的出来

　　右移后的值与0x0f进行按位与运算，这样可以舍弃任何的符号位扩展，以便得到的值可以作为定义数组的下标，从而得到对应数组元素代表的十六进制字符。

　　例如

　　Java代码

　　public class HexByte {

　　public static public void main(String args[]) {

　　char hex[] = {

　　'0', '1', '2', '3', '4', '5', '6', '7',

　　'8', '9', 'a', 'b', 'c', 'd', 'e', 'f''

　　};

　　byte b = (byte) 0xf1;

　　System.out.println("b = 0x" + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);

　　}

　　}

　　(b >> 4) & 0x0f的运算过程：

　　b的二进制形式为：1111 0001

　　4位数字被移出：1111 1111

　　按位与运算:0000 1111

　　转为10进制形式为：15

　　b & 0x0f的运算过程：

　　b的二进制形式为：1111 0001

　　0x0f的二进制形式为：0000 1111

　　按位与运算：0000 0001

　　转为10进制形式为：1

　　所以，该程序的输出如下：

　　b = 0xf1

　　3、无符号右移

　　无符号右移运算符>>>

　　它的通用格式如下所示：

　　value >>> num

　　num 指定要移位值value 移动的位数。

　　无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位

　 无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义
　　无符号右移运算符>>> 只是对32位和64位的值有意义