---
title: "Java日志"
date: 2016-07-05 18:25:18
tags: 日志
---
# Java日志

对于现在的应用程序来说，日志的重要性是不言而喻的。日志所能提供的功能是多种多样的，包括记录程序运行时产生的错误信息、状态信息、调试信息和执行时间信息等。在生产环境中，日志是查找问题来源的重要依据。应用程序运行时的产生的各种信息，都应该通过日志 API 来进行记录。

尽管记录日志是应用开发中并不可少的功能，在 JDK 的最初版本中并不包含日志记录相关的 API 和实现。相关的 API（java.util.logging 包，JUL）和实现，直到 JDK 1.4 才被加入。因此在日志记录这一个领域，社区贡献了很多开源的实现。其中比较流行的包括log4j及其后继者logback。

除了具体的日志记录实现之外，还有一类与`日志记录相关的封装API`，如 Apache Commons Logging和SLF4J。这类库的作用是在日志记录实现的基础上提供一个封装的 API 层次，对日志记录 API 的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。

记录日志只是有效地利用日志的第一步，更重要的是如何对程序运行时产生的日志进行处理和分析。典型的情景包括当日志中包含满足特定条件的记录时，触发相应的通知机制，比如邮件或短信通知；还可以在程序运行出现错误时，快速地定位潜在的问题源。这样的处理和分析的能力对于实际系统的维护尤其重要。当运行系统中包含的组件过多时，日志对于错误的诊断就显得格外重要。

## Java日志组件介绍

Java日志API由以下三个核心组件组成：

* 记录器（Logger）：日志 API 的使用者通过记录器来发出日志记录请求，并提供日志的内容。在记录日志时，需要指定日志的严重性级别。

* 格式化器（Formatter）：对记录器所记录的文本进行格式化，并添加额外的元数据。

* 处理器（Handler）：把经过格式化之后的日志记录输出到不同的地方。常见的日志输出目标包括控制台、文件和数据库等。

当Logger记录一个事件时，它将事件转发给适当的Appender。然后Appender使用Layout来对日志记录进行格式化，并将其发送给控制台、文件或者其它目标位置。另外，Filters可以让你进一步指定一个Appender是否可以应用在一条特定的日志记录上。在日志配置中，Filters并不是必需的，但可以让你更灵活地控制日志消息的流动。

![日志组件关系图](http://i4.bvimg.com/598959/98e17bddc474f66f.png)

**记录器**

当程序中需要记录日志时，首先需要获取一个日志记录器对象。一般的日志记录 API 都提供相应的工厂方法来创建记录器对象。

每个记录器对象都是有名称的。一般的做法是使用当前的 Java 类的名称或所在包的名称作为记录器对象的名称。记录器的名称通常是具有层次结构的，与 Java 包的层次结构相对应。比如 Java 类“com.myapp.web.IndexController”中使用的日志记录器的名称一般是“com.myapp.web.IndexController”或“com.myapp.web”。除了使用类名或包名之外，还可以根据日志记录所对应的功能来进行划分，从而选择不同的名称。比如用“security”作为所有与安全相关的日志记录器的名称。这样的命名方式对于某些横切的功能比较实用。

开发人员一般习惯于使用当前的类名作为日志记录器的名称，这样可以快速在日志记录中定位到产生日志的 Java 类。使用有意义的其他名称在很多情况下也是一个不错的选择。

`在通过日志记录器对象记录日志时，需要指定日志的严重性级别`。根据每个记录器对象的不同配置，低于某个级别的日志消息可能不会被记录下来。该级别是日志 API 的使用者根据日志记录中所包含的信息来自行决定的。不同的日志记录 API 所定义的级别也不尽相同。日志记录封装 API 也会定义自己的级别并映射到底层实现中相对应的实际级别。

每个记录器对象都有一个运行时对应的严重性级别。该级别可以通过配置文件或代码的方式来进行设置。如果没有显式指定严重性级别，则会根据记录器名称的层次结构关系往上进行查找，直到找到一个设置了严重性级别的名称为止。比如名称为“com.myapp.web.IndexController”的记录器对象，如果没有显式指定其严重性级别，则会依次查找是否有为名称“com.myapp.web”、“com.myapp”和“com”指定的严重性级别。如果仍然没有找到，则使用根记录器配置的值。

通过记录器对象来记录日志时，只是发出一个日志记录请求。该请求是否会完成取决于请求和记录器对象的严重性级别。记录器使用者产生的低于记录器对象严重性级别的日志消息不会被记录下来。这样的记录请求会被忽略。`除了基于严重性级别的过滤方式之外，日志记录框架还支持其他自定义的过滤方式`。

**格式化器**

实际记录的日志中除了使用记录器对象时提供的消息之外，还包括一些元数据。这些元数据由日志记录框架来提供。常用的信息包括记录器的名称、时间戳、线程名等。格式化器用来确定所有这些信息在日志记录中的展示方式。不同的日志记录实现提供各自默认的格式化方式和自定义支持。

**日志处理器**

日志记录经过格式化之后，由不同的处理器来进行处理。不同的处理器有各自不同的处理方式。比如控制台处理器会把日志输出到控制台中，文件处理器把日志写入到文件中。除了这些之外，还有写入到数据库、通过邮件发送、写入到 JMS 队列等各种不同的处理方式。
日志处理器也可以配置所处理日志信息的最低严重性级别。低于该级别的日志不会被处理。这样可以控制所处理的日志记录数量。比如控制台处理器的级别一般设置为 INFO，而文件处理器则一般设置为 DEBUG。
日志记录框架一般提供了比较多的日志处理器实现。开发人员也可以创建自定义的实现。

**MDC**

MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。典型的例子是 Web 应用服务器。当用户访问某个页面时，应用服务器可能会创建一个新的线程来处理该请求，也可能从线程池中复用已有的线程。在一个用户的会话存续期间，可能有多个线程处理过该用户的请求。这使得比较难以区分不同用户所对应的日志。当需要追踪某个用户在系统中的相关日志记录时，就会变得很麻烦。

一种解决的办法是采用自定义的日志格式，把用户的信息采用某种方式编码在日志记录中。这种方式的问题在于要求在每个使用日志记录器的类中，都可以访问到用户相关的信息。这样才可能在记录日志时使用。这样的条件通常是比较难以满足的。MDC 的作用是解决这个问题。

MDC可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。MDC中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容。当需要记录日志时，只需要从MDC中获取所需的信息即可。MDC 的内容则由程序在适当的时候保存进去。对于一个 Web 应用来说，通常是在请求被处理的最开始保存这些数据。

## Java日志全解析

Java 拥有功能和性能都非常强大的日志库；不幸的是，这样的日志库有不止一个——相信每个人都曾经迷失在JUL(Java Util Log), JCL(Commons Logging), Log4j, SLF4J, Logback，Log4j2 等等的迷宫中。

* **Java Util Log(JUL)**

  JDK中自带的log功能。虽然是官方自带的log lib，JUL的使用确不广泛。主要原因:

  * JUL从JDK1.4 才开始加入(2002年)，当时各种第三方log lib已经被广泛使用了；

  * JUL早期存在性能问题，到JDK1.5上才有了不错的进步，但现在和Logback/Log4j2相比还是有所不如；

  * JUL的功能不如Logback/Log4j2等完善，比如Output Handler就没有Logback/Log4j2的丰富，有时候需要自己来继承定制，又比如默认没有从ClassPath里加载配置文件的功能。

* **Log4j 1.x**

  Log4j是在Logback出现之前被广泛使用的Log Lib, 由Gülcü于2001年发布，后来成为Apache 基金会的顶级项目。Log4j在设计上非常优秀，对后续的 Java Log框架有长久而深远的影响，也产生了Log4c, Log4s, Log4perl等到其他语言的移植。Log4j的短板在于性能，在Logback和Log4j2出来之后，Log4j的使用也减少了。

* **Apache Common-Logging(JCL)**

  目前广泛使用的Java日志门面库。通过动态查找的机制，在程序运行时自动找出真正使用的日志库。但由于它使用了ClassLoader寻找和载入底层的日志库， 导致了象OSGI这样的框架无法正常工作，由于其不同的插件使用自己的ClassLoader。 OSGI的这种机制保证了插件互相独立，然而确使Apache Common-Logging无法工作。

  ![](http://i1.bvimg.com/598959/82e4cb41c1e52fcf.png)

* **SLF4J/Logback**

  SLF4J(The Simple Logging Facade for Java)和Logback也是Gülcü创立的项目，SLF4J 库类似于 Apache Common-Logging。但是，他在编译时静态绑定真正的Log库。使用SLF4J时，如果你需要使用某一种日志实现，那么你必须选择正确的SLF4J的jar包的集合，如此便可以在OSGI中使用了。另外，SLF4J 支持参数化的log字符串，避免了之前为了减少字符串拼接的性能损耗而不得不写的`if(logger.isDebugEnable())`，现在你可以直接写：`logger.debug(“current user is: {}”, user)`。拼装消息被推迟到了它能够确定是不是要显示这条消息的时候，但是获取参数的代价并没有幸免。

  而Logback则是作为Log4j的继承者来开发的，提供了性能更好的实现，异步logger，Filter等更多的特性。

  现在事情变复杂了。我们有了两个流行的Log Facade，以及三个流行的Log Implementation。Gülcü 是个追求完美的人，他决定让这些Log之间都能够方便的互相替换，所以做了各种Adapter和Bridge来连接:

  ![](http://i1.bvimg.com/598959/74fe31dbd6fbff88.png)

  可以看到甚至Log4j和JUL都可以桥接到SLF4J，再通过SLF4J适配到到Logback! 在这里需要注意不能搞出循环的桥接，比如下面这些依赖就不能同时存在:
  1. jcl-over-slf4j 和 slf4j-jcl
  2. log4j-over-slf4j 和 slf4j-log4j12
  3. jul-to-slf4j 和 slf4j-jdk14

* **Log4j2**

  Log4j2和Log4j1.x并不兼容，设计上很大程度上模仿了SLF4J/Logback，性能上也获得了很大的提升。

  Log4j2也做了Facade/Implementation分离的设计，分成了log4j-api和log4j-core。

  现在好了，我们有了三个流行的Log接口和四个流行的Log实现，如果画出桥接关系的图来回事什么样子呢?

  ![](http://i1.bvimg.com/598959/ff9d7a69d359856e.png)

## 日志记录最佳实践

* **具体的日志实现依赖应该设置为optional和使用runtime scope**

  在项目中，Log Implementation的依赖强烈建议设置为runtime scope，并且设置为optional。例如项目中使用了 SLF4J 作为 Log Facade，然后想使用 Log4j2 作为 Implementation，那么使用 maven 添加依赖的时候这样设置:

  ```xml
  <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>${log4j.version}</version>
      <scope>runtime</scope>
      <optional>true</optional>
  </dependency>
  <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-slf4j-impl</artifactId>
      <version>${log4j.version}</version>
      <scope>runtime</scope>
      <optional>true</optional>
  </dependency>
  ```

  设为optional，依赖不会传递，这样如果你是个lib项目，然后别的项目使用了你这个lib，不会被引入不想要的Log Implementation 依赖；

  Scope设置为runtime，是为了防止开发人员在项目中直接使用Log Implementation中的类，而不适用Log Facade中的类。

* **避免为不会输出的log付出代价**

  Log库都可以灵活的设置输出界别，所以每一条程序中的log，都是有可能不会被输出的。这时候要注意不要额外的付出代价。

  先看两个有问题的写法：
  ```java
  logger.debug("start process request, url: " + url);
  logger.debug("receive request: {}", toJson(request));
  ```
  第一条是直接做了字符串拼接，所以即使日志级别高于debug也会做一个字符串连接操作；第二条虽然用了SLF4J/Log4j2 中的懒求值方式来避免不必要的字符串拼接开销，但是toJson()这个函数却是都会被调用并且开销更大。

  推荐的写法如下:
  ```java
  logger.debug("start process request, url:{}", url); // SLF4J/LOG4J2
  logger.debug("receive request: {}", () -> toJson(request)); // LOG4J2
  logger.debug(() -> "receive request: " + toJson(request)); // LOG4J2
  if (logger.isDebugEnabled()) { // SLF4J/LOG4J2
      logger.debug("receive request: " + toJson(request));
  }
  ```

* **日志中包含充分的信息**

  日志中所包含的信息应该是充分的。在记录日志消息时应该尽可能多的包含当前上下文中的各种信息，以方便在遇到问题时可以快速的获取到所需的信息。比如在网上支付功能中，与支付相关的日志应该完整的包含当前用户、订单以及支付方式等全部信息。一种比较常见的做法是把相关的日志记录分散在由不同日志记录器所记录的日志中。

* **使用合适的日志记录器名称**

  一般的日志记录实践是使用当前 Java 类的全名作为其使用的日志记录器的名称。这样做可以得到一个与 Java 类和包的层次结构相对应的日志记录器的层次结构。可以很方便的按照不同的模块来设置相应的日志记录级别。不过对于某些全局的或是横切的功能，如安全和性能等，则推荐使用功能相关的名称。比如程序中可能包含用来提供性能剖析信息的日志记录。对于这样的日志记录，应该使用同一名称的日志记录器，如类似“performance”或“performance.web”。这样当需要启用和禁用性能剖析时，只需要配置这些名称的记录器即可。

* **使用半结构化的日志消息**

  日志记录中除了基本的日志消息之外，还包括由日志框架提供的其他元数据。这些数据按照给定的格式出现在日志记录中。这些半结构化的格式使得可以通过工具提取日志记录中的相关信息进行分析。在使用日志 API 进行记录时，对于日志消息本身，也推荐使用半结构化的方式来组织。

  比如一个电子商务的网站，当用户登录之后，该用户所产生的不同操作所对应的日志记录中都可以包含该用户的用户名，并以固定的格式出现在日志记录中，如下所示：

  ```txt
  [user1] 用户登录成功。
  [user1] 用户成功购买产品 A。
  [user2] 订单 003 付款失败。
  ```

  当需要通过日志记录来排查某个用户所遇到的问题时，只需要通过正则表达就可以很快地查询到用户相关的日志记录。

* **日志聚合与分析**

  在程序中正确的地方输出合适的日志消息，只是合理使用日志的第一步。日志记录的真正作用在于当有问题发生时，能够帮助开发人员很快的定位问题所在。不过一个实用的系统通常由很多个不同的部分组成。这其中包括所开发的程序本身，也包括所依赖的第三方应用程序。以一个典型的电子商务网站为例，除了程序本身，还包括所依赖的底层操作系统、应用服务器、数据库、HTTP 服务器和代理服务器和缓存等。当一个问题发生时，真正的原因可能来自程序本身，也可能来自所依赖的第三方程序。这就意味着开发人员可能需要检查不同服务器上不同应用程序的日志来确定真正的原因。

  日志聚合的作用**就在于可以把来自不同服务器上不同应用程序产生的日志聚合起来，存放在单一的服务器上，方便进行搜索和分析**。在日志聚合方面，已经有不少成熟的开源软件可以很好的满足需求。

## 参考文章

* [Java 日志管理最佳实践](https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/)

* [Java日志全解析(上) - 源流](https://zhuanlan.zhihu.com/p/24272450)

* [Java日志全解析(下) - 最佳实践](https://zhuanlan.zhihu.com/p/24275518)

logback mdc 日志跟踪